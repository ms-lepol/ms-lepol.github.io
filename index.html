<!doctype html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Carré, déplacement, obstacles, collisions</title>
    <script>
    
    // la référence pour apprendre Javascript facilement : 
    //    http://www.w3schools.com/js/default.asp
    // le code ci-dessous contient les références aux pages concernées de ce site
        
    // 2D context : objet dans lequel on va réaliser les dessins (en 2D)
    // --> voir http://www.w3schools.com/jsref/dom_obj_canvas.asp
    //  pour connaître les fonctions offertes par cet objet
    
    // --> voir http://www.html5canvastutorials.com 
    //  pour tout savoir de l'utilisation des canvas
    
    // --> voir http://www.html5rocks.com/en/tutorials/canvas/performance/
    //  pour tout savoir sur l'optimisation des performances dans les canvas
    let context = null;
        
    // rectangle dans le jeu :
    let rectangle = {hauteur: 64, largeur: 64,x: 0, y: 0, couleur: "red", speed: 0.5 };
    let rectnew = {hauteur: 64, largeur: 64, x: Number, y: Number};

    //variable d'état du jeu
    let etat = 'deb';
    // obstacles dans le jeu
    let obstacles = [];
    let nbObs = 5;
    obstacles[0]={x : Number, y : Number, largeur:Number,largeur:Number,couleur:'black'}
    obstacles[1]={x : Number, y : Number, largeur:Number,largeur:Number,couleur:'black'}
    obstacles[2]={x : Number, y : Number, largeur:Number,largeur:Number,couleur:'black'}
    obstacles[3]={x : Number, y : Number, largeur:Number,largeur:Number,couleur:'black'}
    obstacles[4]={x : Number, y : Number, largeur:Number,largeur:Number,couleur:'black'}

    // clic sur la zone de jeu (coordonnées relatives au canvas)
    let clic = { x: 0, y: 0 };
    
    //Variable de la différence de temps entre deux frames
    let dT;
    let lastD = 0;
    //vecteur de déplacement
    let dir = { x: 0, y: 0 };
    // initialisation (appelée au chargement du corps du document <body onload="init">)    
    function init() {        
         // instanciation de la variable globale contenant le contexte
           context = document.getElementById("cvs").getContext("2d");
           context.width = document.getElementById("cvs").width;
           context.height = document.getElementById("cvs").height;
           context.font = '20px serif';
           context.textAlign = "center";
        context.fillText('Appuyez sur ENTER pour continuer',context.width/2,context.height/2);
           //init de la position du rectangle
           rectangle.x=context.width/2-rectangle.largeur/2;
           rectangle.y=context.height/2-rectangle.hauteur/2;
            rectnew.y=rectangle.y;
            rectnew.x=rectangle.x;

           //init de la position des rectangles
           genObstacle();
            
           // 2 écouteurs pour le clavier (appui/relâchement d'une touche)
           document.addEventListener("keydown", captureAppuiToucheClavier)
           document.addEventListener("keyup", captureRelacheToucheClavier)
           // on associe au document un écouteur d'événements souris
           document.addEventListener("click", captureClicSouris)
        // --> ces événements vont appeler les fonctions captureXYZ définies après.
          
        // lancement de la boucle de jeu    
        boucleDeJeu();
            
        
    }
    
    
    function boucleDeJeu() {
         // mise à jour de l'état du jeu
        update(Date.now()); 
        
        if (etat == 'jeu'){      
            // affichage de l'état du jeu
            render();
        }
        if (etat == 'pause'){
            afficherPause()
        }

        // rappel de la boucle de jeu 
        // requestAnimationFrame est une fonction JS servant à pré-calculer le prochain affichage
        //  http://www.html5canvastutorials.com/advanced/html5-canvas-animation-stage/
        requestAnimationFrame(boucleDeJeu);

    }
    
    function afficherPause(){
        context.fillText('Pause, appuyez sur SPACE pour continuer',context.width/2,context.height/2);

    }
    /**
     *  Mise à jour de l'état du jeu
     *  @param  d   date courante
     */
    function update(d) {
            let dT = d-lastD;
            lastD=d;
        if (etat == 'jeu'){
            movRect(dT);
        }
    }
    
    
    /**
     *  Fonction réalisant le rendu de l'état du jeu
     */
    function render() {
        // effacement de l'écran
        context.clearRect(0, 0, context.width, context.height);
        //affichage du rectangle
        context.fillStyle=rectangle.couleur;
        context.fillRect(rectangle.x,rectangle.y,rectangle.largeur,rectangle.hauteur);
        

        //affichage des obstacles
        affichageObs()
        
    }
    /**
     *  Fonction appelée lorsqu'une touche du clavier est appuyée
     *  Associée à l'événement "keyDown"
     */
    function captureAppuiToucheClavier(event) {
        // pratique pour connaître les keyCode des touches du clavier :
        //  --> http://www.cambiaresearch.com/articles/15/javascript-key-codes
             
        //mouvement
        switch(event.code){
            case "ArrowUp":
                dir.y = -1;
                break;
            case "ArrowDown":
                dir.y = 1;
                break;
            case "ArrowLeft":
                dir.x = -1
                break;
            case "ArrowRight":
                dir.x = 1
                break;
            case "Enter":
                if (etat =='deb')
                    etat = 'jeu';
                break;
            case "Space":
                if (etat=="jeu"){ etat = "pause";} else{
                if (etat =="pause"){ etat = "jeu";}}
                break;
        }

        //
    }
    
    /**
     *  Fonction appelée lorsqu'une touche du clavier est relâchée
     *  Associée à l'événement "keyUp"
     */
    function captureRelacheToucheClavier(event){
        switch(event.key){
            case "ArrowUp":
                if (dir.y < 0) dir.y = 0;
                break;
            case "ArrowDown":
                if (dir.y > 0) dir.y = 0;
                break;
            case "ArrowLeft":
                if (dir.x < 0) dir.x = -0;
                break;
            case "ArrowRight":
                if (dir.x > 0) dir.x = 0;
                break;
        }
    }
    /**
     *  Fonction appelée lorsqu'une touche du clavier est relâchée
     *  Associée à l'événement "click"
     */
    function captureClicSouris(event) {
        // calcul des coordonnées de la souris dans le canvas
        if (event.target.id == "cvs") {
            clic.x = event.pageX - event.target.offsetLeft;
            clic.y = event.pageY - event.target.offsetTop;
        }

        if (((clic.x <=rectangle.x+rectangle.largeur) && (clic.x >=rectangle.x)) && ((clic.y>=rectangle.y) && (clic.y<=rectangle.y+rectangle.hauteur))){
            console.log("Touché");
            rectangle.couleur=chgmtColor(rectangle.couleur);
        }
    }
    

    /*
     * Fonction qui va calculer la position du carré
     *
     */
    function movRect(dT){
        let col;
        //Verification que l'on est dans l'espace de la fenêtre et déplacement du carré
        if ((rectangle.x>=0) && (rectangle.x+rectangle.largeur<=context.width)){
            rectnew.x = rectangle.x + dir.x*rectangle.speed*dT;
            rectnew.y = rectangle.y;
            col = checkCollisionList(rectnew,obstacles);
            if (col == null){
                rectangle.x = rectnew.x;
            }
            else{
                //Si collision G 
                if (dir.x>0/* && dir.y==0*/){
                    rectangle.x = obstacles[col].x-rectangle.largeur;
                }
                //si collision D
                else if (dir.x<0/* && dir.y == 0*/){
                    rectangle.x = obstacles[col].x+obstacles[col].largeur
                }
            }
        }
        if ((rectangle.y>=0) && (rectangle.y+rectangle.largeur<=context.height)){
            rectnew.x = rectangle.x;
            rectnew.y = rectangle.y+ dir.y*rectangle.speed*dT;
            col = checkCollisionList(rectnew,obstacles);
            if (col == null){
                rectangle.y = rectnew.y;
            }
            else{
                //Si collision H 
                if (dir.y>0 /*&& dir.x==0*/){
                    rectangle.y = obstacles[col].y-rectangle.hauteur;
                }
                //si collision B
                else if (dir.y<0 /*&& dir.x==0*/){
                    rectangle.y = obstacles[col].y+obstacles[col].hauteur;
                }
            }
        }

        //Verification des Bords et replacement du carré si il touche les bords
        if (rectangle.x < 0){
            rectangle.x = 0;
        }
        if (rectangle.x > context.width-rectangle.largeur){
            rectangle.x = context.width-rectangle.largeur;
        }

        if (rectangle.y < 0){
            rectangle.y = 0;
        }
        if (rectangle.y > context.height-rectangle.hauteur){
            rectangle.y = context.height-rectangle.hauteur;
        }
    }

    /*
     * fonction du changement de couleur
     */

     function chgmtColor(color){
        switch(color){
            case "red":
                color = "green";
                break;
            case "green":
                color = "blue";
                break;
            case "blue":
                color = "yellow";
                break;
            case "yellow":
                color = "orange";
                break;
            case "orange":
                color = "red";
                break;
        }
        return color;
     }
     /*
      * Fonction de génération des obstacles
      */
     function genObstacle(){
       //declaration des paramètres de générations des Obstacles
        let i=0;
        let wMin = 50;
        let hMin = 50;
        let wMax = 200;
        let hMax = 200;

        for (i=0;i<obstacles.length;i++){
            do {
                obstacles[i].x = Math.random()*context.width+1;
                obstacles[i].y = Math.random()*context.height+1;
                obstacles[i].largeur = wMin + Math.random()*wMax+1;
                obstacles[i].hauteur = hMin + Math.random()*hMax+1;
            } while (checkCollision(rectangle,obstacles[i]));
            
        }
     }
     /*
      * fonction d'affichage des obstacles
      */
     function affichageObs(){
         let i=0;
         
         for (i=0;i<obstacles.length;i++){
            context.fillStyle = obstacles[i].couleur;
            context.fillRect(obstacles[i].x,obstacles[i].y,obstacles[i].largeur,obstacles[i].hauteur);
         }
     }

    function checkCollision(rectangle,obstacles){
            return !(rectangle.x+rectangle.largeur <= obstacles.x || 
            rectangle.x>= obstacles.x+obstacles.largeur ||
            rectangle.y+rectangle.hauteur<=obstacles.y ||
            rectangle.y>=obstacles.y+obstacles.hauteur);
    }

    function checkCollisionList(rectangle,obstacles){
        let i = 0;

        for (i=0;i<obstacles.length;i++){
            if (checkCollision(rectangle,obstacles[i])){
                return i;
            }
        }                
        return null;

    }
   
    </script>
</head>

<body onload="init()">

    <canvas id="cvs" width="800" height="600" style="margin: 10px auto; border: solid 1px rgb(116, 9, 9);"></canvas>

</body>

</html>